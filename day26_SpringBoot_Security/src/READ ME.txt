same config but adding Security dependency

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>

-------------------------------------------------------------------------------------------------

copy content from day24_SpringBoot_JPA_MySQL_SMS

just by putting the security dependency on pom.xml :
    it will automatically generate security password on run console
         Using generated security password: b154aa07-9fe5-41e2-af19-2efd90fb4f71
    default username isf not set on application.properties is : user

changing default username & password : on application.properties

    spring.security.user.name = username
    spring.security.user.password = pwd

the new settings :

    Username : username
    Password : pwd

after putting the password on application.properties :
    notice that the autogenerated security password is gone on run console


-------------------------------------------------------------------------------------------------

Postman :  Auth -> TYPE : Basic Auth

default setting :
    USERNAME :  user
    PASSWORD : generated on run console -> i.e. b154aa07-9fe5-41e2-af19-2efd90fb4f71

-------------------------------------------------------------------------------------------------

let's now add ADMIN and USER role configurations :

under domain -> create User class (id,name,username,password,authority)
    => @Entity
    => implements UserDetails
        => alt enter then implement all the methods
        => make return true all the false on the methods
        => make return this.password and this.username on corresponding methods
        => make return Arrays.asList(new SimpleGrantedAuthority(authority)); on getAuthorities() method
        => NOTE : the authority parameter above is not string!!!!!!!!! - that took whole day to figure out!!!!!!!
    => @Id
    => @GeneratedValue(strategy = "")

under repository -> create UserRepository interface
    => @Repository
    => extends JpaRepository<User,Long>
    => User findByUsername(String username)

under service -> create UserService class
    => @Service
    => @Autowired
    => make addUser(User user) method -> initially for default user account
        will be used for @PostConstruct method
    => @PostConstruct
        => will be executed first : make a default user account
    => implements UserDetailsService
        => alt enter then implement method

under controller -> create UserController class
    => @RestController
    => @RequestMapping
    => @Autowired

    => @PreAuthorized
        The @PreAuthorize can check for authorization before entering into method.
        The @PreAuthorize authorizes on the basis of role or the argument which is passed to the method

    => @PostMapping -> method with @RequestBody to addUser
    => @GetMapping -> method to get currently logged in user

under com.example.day26_SpringBoot_Security -> create configuration/SecurityConfig class
    => @Configuration
    => @EnableGlobalMethodSecurity(prePostEnabled = true)
    => @Autowired
    => create @Bean for password encryption using BCryptPasswordEncoder()
        => see database actual encryption made on password column
    => extends WebSecurityConfigurerAdapter
        alt insert then override methods
        select configure(HttpSecurity http) &
        configure(AuthenticationManagerBuilder auth)

---------------------------------------------------------------------------------------------------

upon running the code

MySQL : user table

id, authority, name,       password,                                                     username
'1', 'ADMIN', 'john doe', '$2a$10$p3Kjt4hUaOiHP0f2toJGYuaDIpd74MPB26j9hI74nWR/67hW16zky', 'username'


---------------------------------------------------------------------------------------------------

error encountered :


***************************
APPLICATION FAILED TO START
***************************

Description:

The dependencies of some of the beans in the application context form a cycle:

┌─────┐
|  securityConfig defined in file [C:\Users\mmacaranas\Downloads\day26_SpringBoot_Security\target\classes\com\example\day26_SpringBoot_Security\configuration\SecurityConfig.class]
↑     ↓
|  userService defined in file [C:\Users\mmacaranas\Downloads\day26_SpringBoot_Security\target\classes\com\example\day26_SpringBoot_Security\service\UserService.class]
└─────┘

root cause :

        public SecurityConfig(UserService userService){
            this.userService = userService;
        }

should be remove on SecurityConfig class

---------------------------------------------------------------------------------------------------
we only have user1, user2 (hard coded on SecurityConfig class) and username (the only default on DB) account

user1 & user2 will have access on below but none for the username (the only default on DB):
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me


    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
                .inMemoryAuthentication()
                .withUser("user1")
                .password(passwordEncoder().encode("pwd1"))
                .roles("USER")
                .and()
                .withUser("user2")
                .password(passwordEncoder().encode("pwd2"))
                .roles("USER");
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .httpBasic()
                .and()
                .authorizeRequests()
                .antMatchers("/users/register").hasAuthority("ADMIN")
                .anyRequest()
                .authenticated()
                .and()
                .csrf()
                .disable();
    }

---------------------------------------------------------------------------------------------------
we only have user1, user2 (hard coded on SecurityConfig class) and username (the only default on DB) account

user1 & user2 will have access on below but none for the username (the only default on DB):
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me
    POST :   localhost:8080/users/register


    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
                .inMemoryAuthentication()
                .withUser("user1")
                .password(passwordEncoder().encode("pwd1"))
                .roles("USER")
                .and()
                .withUser("user2")
                .password(passwordEncoder().encode("pwd2"))
                .roles("USER");
    }


    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .httpBasic()
                .and()
                .authorizeRequests()
                .anyRequest()
                .authenticated()
                .and()
                .csrf()
                .disable();
    }

---------------------------------------------------------------------------------------------------
we only have user17 and username account (both on DB)

username (default admin) will have access on :
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me
user7 will have access on :
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me


    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .httpBasic()
                .and()
                .authorizeRequests()
                .antMatchers("/users/register").hasAuthority("ADMIN")
                .anyRequest()
                .authenticated()
                .and()
                .csrf()
                .disable();
    }

---------------------------------------------------------------------------------------------------
we only have user77 and username account (both on DB)

username (default admin) will have access on :
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me
    POST :   localhost:8080/users/register
user77 will have access on :
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me
    POST :   localhost:8080/users/register

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .httpBasic()
                .and()
                .authorizeRequests()
                .anyRequest()
                .authenticated()
                .and()
                .csrf()
                .disable();
    }

---------------------------------------------------------------------------------------------------
adding @EnableGlobalMethodSecurity(prePostEnabled = true) on SecurityConfig
    and PreAuthorize("hasAuthority('ADMIN')") on UserController @PostMapping("register")

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .httpBasic()
                .and()
                .authorizeRequests()
                .anyRequest()
                .authenticated()
                .and()
                .csrf()
                .disable();
    }

we have default admin and user77 account with password pwd & pwd77 respectively :

admin can access all
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me
    POST :   localhost:8080/users/register
user77 can access only
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me



---------------------------------------------------------------------------------------------------
adding @EnableGlobalMethodSecurity(prePostEnabled = true) on SecurityConfig
    and PreAuthorize("hasAuthority('ADMIN')") on UserController @PostMapping("register")

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userService);
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .httpBasic()
                .and()
                .authorizeRequests()
                 .antMatchers("/users/register").hasAuthority("ADMIN")
                .anyRequest()
                .authenticated()
                .and()
                .csrf()
                .disable();
    }

we have default admin and user77 account with password pwd & pwd77 respectively :

admin can access all
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me
    POST :   localhost:8080/users/register
user77 can access only
    GET :    localhost:8080/students/
    POST :   localhost:8080/students/
    GET :    localhost:8080/users/me

@PreAuthorize is only applicable to method where it was put !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

---------------------------------------------------------------------------------------------------
for condition :

    @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.userDetailsService(userService);
        }

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .httpBasic()
                    .and()
                    .authorizeRequests()
                    .anyRequest()
                    .authenticated()
                    .and()
                    .csrf()
                    .disable();
        }

added @PreAuthorize("hasAuthority('ADMIN')") on StudentController below :

    @PreAuthorize("hasAuthority('ADMIN')")
    @GetMapping
    public List<Student> getAllStudent(){
        return studentService.getAllStudents();
    }

and reomved the @PreAuthorize("hasAuthority('ADMIN')") on UserConttroller @PostMapping("register")

    admin can access all
        GET :    localhost:8080/students/
        POST :   localhost:8080/students/
        GET :    localhost:8080/users/me
        POST :   localhost:8080/users/register
    user77 can access only
        POST :   localhost:8080/students/
        GET :    localhost:8080/users/me
        POST :   localhost:8080/users/register


---------------------------------------------------------------------------------------------------

Best Practices that saves time :

=> use only one tab on postman for testing : to avoid username and password errors
=> use mock data that will make sense and right for the fields specially in JSON Postman POST!!!!!!!!!!
    might cause errors if data is wrong - make sure field name on JSON and DB column is correct!!!!!!!!
=> have a systematic way of testing things and stick to it! make a list or pattern on how to test things!!!!!










